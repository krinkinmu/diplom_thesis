\chapter{Обзор предметной области и постановка задачи}

\section{Динамическая и статическая трансляция}

\textit{2 страницы}

\begin{Def}\label{binary_translation}
Бинарная трансляция - эмуляция одного набора инструкций через другой набор инструкций, т. е. трансляция последовательности инструкций исходного набора в эквивалентную последовательность инструкций целевого набора комманд.
\end{Def}

В зависимости от необходимости исполнения исходной последовательности иснтрукций бинарную трансляцию разделяют на статическую и динамическую.

Статическая трансляция не подразумевает интерпретацию исходной последовательности, в то время как динамическая трансляция подразумевает интрепретацию исходной последовательности комманд.

Технологии бинарной трансляции используются очень широко, например, вирутальные машины Java и .NET преобразуют байт-код в машинный код целевой платформы, что является частным случаем бинарной трансляции.

QEMU осуществляет бинарную трансляцию для эмуляции набора комманд одного процессора на другом, что позволяет использовать его, например, вместо реального аппартного обеспечения при разработке программных продуктов.

Популярный профилировщик Valgrind осуществляет бинарную трансляции в свое внутренне представление VEX IR~\footnote{http://www.valgrind.org/docs/manual/writing-tools.html}, в котором проще инструментировать код.

\subsection{Статическая трасляция}

В связи с необходимости сохранения семантики исходной последовательности комманд, например, атомарность определенных инструкций, статическая трансляция является довольно сложной, кроме того, как я уже писал выше, имея только исполняемый файл в общем случае нельзя отличить бинарный код от данных программы без интерпретации бинарного кода, что ограничивает применение этого подхода.

Существуют различные реализации статических трансляторов, например, Ngen~\footnote{http://en.wikipedia.org/wiki/Native\_Image\_Generator} производит статическую трансляцию CIL в бинарный код целевой платформы, аналогичные средства есть для байт-кода Java~\footnote{http://en.wikipedia.org/wiki/GNU\_Compiler\_for\_Java}~\footnote{http://en.wikipedia.org/wiki/Excelsior\_JET}.

Следует отметить, что технологии статической трансляции могут применяться не только для преобразования последовательностей инструкций из разных наборов комманд, но и для преобразования последовательности комманд в рамках одного набора инструкций, например, с целью оптимизации~\footnote{http://www.cs.arizona.edu/projects/alto/}.

\subsection{Динамическая трансляция}

По сравнению со статической динамическая трансляция имеет меньше ограничений, но за большую свободу часто приходится платить меньшей производительностью из-за накладных расходов на интерпретацию, которых нет при статической трансляции.

Однако не всегда производительность динамической трансляции ниже. Для ускорения может применяться техника Just In Time (JIT) компиляции, когда последовательности инструкций исходной платформы компилируются "на лету" в набор инструкций целевой платформы, что уменьшает накладные расходы. Кроме того при использовании JIT возможно использование оптимизаций недоступных при статической трансляции. Так JIT компилятору доступна, например, информация о наиболее горячих участках программы, что позволяет сгенерировать более оптимальный, по сравнению со статически сгенерированным, бинарный код.

В качестве примеров динамических трансляторов можно привести вирутальные машины Java и .NET, а в качестве примера транслятора нативного кода QEMU и Valgrind.

В своей работе в качестве динамическго транслятора я использую QEMU, так как он поддерживает множество аппаратных платформ (в том числе и arm), а кроме того имеет режим User Mode (для Linux и Free BSD), в котором он виртуализует не целую вычислительную систему, а только окружение одного процесса и осуществляет трансляцию системных вызовов исходной платформы (в рамках моей работы x86) в системные вызовы целевой (в рамках моей работы arm).

\section{Существующие реализации миграции}

Как я уже писал выше, существуют различные реализации технологий миграции процессов, далее коротко будут рассмотрены 4 наиболее близких к моей работе.

\subsection{Linux-cr}

Проект по реализации технологии checkpoint/restore в ядре Linux~\footnote{https://ckpt.wiki.kernel.org/index.php/Main\_Page}. На данный момент проект не выглядит активным, последняя активность в ноябре 2010 года~\cite{linux_cr_lwn_report}. На момент последней актвности код состоял из около 100 патчей в ядро Linux и содержал порядка 23 000 строк кода.

Основной проблемой проекта была попытка реализации проекта в пространстве ядра, так как он затрагивает большое количество подсистем, что усложняет поддержку и развитие проекта, а ошибки в системе миграции влияют на работу всей системы, делая ядро хрупким. Именно поэтому в своей работе я стараюсь минимизировать вмешательство в ядро Linux и получить как можно больше информации в пространстве пользователя.

Проект обладает достаточно большим списком поддерживаемых фич, кроме того поддерживает несколько архитектур: x86, x86\_64, PowerPC, s390 и arm.

Список поддерживаемых фич:

\begin{itemize}

    \item поддержка многопоточных программ
    \item поддержка фьютексов
    \item поддержка сигналов
    \item файловые дескрипторы и директории для различных файловых систем
    \item файлы устройств (/dev/null, /dev/zero, /dev/random, /dev/urandom)
    \item поддержка epoll и event
    \item поддержка сокетов unix, ipv4 и ipv6 сокетов

\end{itemize}

но даже этот спсиок не описывает все ресурсы, которые необходимо поддержать для полноценной миграции процессов.

\subsection{CRIU}

CRIU проект по реализации технологии checkpoint/restore преимущественно в пространстве пользователя Linux~\footnote{http://criu.org/Main\_Page}. Проект развивается при поддержке компании Paralles и находится в активной разработке.

Поддерживаемые фичи:

\begin{itemize}

    \item сохранение и восстановление TCP соединений
    \item сохранение и восстановление файловых дескрипторов
    \item поддрежка многопоточных программ
    \item поддержка со стороны mainstream ядра

\end{itemize}

К сожалению, CRIU поддердивает только платформу x86\_64, что делает его неприменимым для кросс-архитектурной миграции процессов.

\subsection{DMTCP}

Проект по реализации технологии checkpoint/restart на уровне библиотек~\footnote{http://dmtcp.sourceforge.net/index.html}. Проект развиватеся, возможно, не очень активно, последняя версия 1.2.7 выпущена 13 марта 2013 года. Принцип работы заключается в запуске целевого процесса в специальном окружении, которое позволяет перехватывать некоторые вызовы и таким образом отслеживать состояние. DMTCP реализован в пространстве пользователя и поддерживает как многопоточные так и распределенные системы.

В связи с тем, что отслеживание состояния происходит во время работы процесса за счет перехвата библиотечных вызовов, существует некоторо падение производительности. Кроме того возможности этого проекта нужно оценивать уже не на уровне ресурсов ОС, а на уровне поддерживаемых библиотек и приложений.

На данный момент, DMTCP поддерживает следующие приложения и библиотеки:

\begin{itemize}

    \item OpenMPI (в частности MPICH2)
    \item MATLAB
    \item Python
    \item Perl
    \item GNU screen
    \item X Window приложения без расширений (например, без OpenGL)
    \item и многие другие

\end{itemize}

Следует отметить, что такая реализация потенциально небезопасна~\footnote{http://criu.org/Comparison\_to\_other\_CR\_projects}. Например, DMTCP умеет перехватывать библиотечный вызов getpid, возвращая ненастоящий pid процесса, но если, этот идентификатор используется для доступа, например, к файловой системе proc. В этом случае, без дополнительной трансляции имен файлов, процесс попытается обратиться к неправильному файлу - файлу другого процесса или несуществующему файлу, хотя в случае поддержки на уровне приложений, это, вероятно, не является проблемой.

\subsection{BLCR}

Проект по реализации checkpoint/restart лаборатории Berkeley~\footnote{https://ftg.lbl.gov/projects/CheckpointRestart/}. Проект направлен на гибридную (пространство пользователя/пространство ядра) реализацию checkpoint/restart не требующую изменения в коде приложения. Проект сосредоточен на параллельных и распределенных приложениях использующих MPI. Поддержка в ядре Linux не требует внесения специальных изменений в ядро и поставляется в вижде набора модулей ядра.

Проект не выглядит активным, последняя версия 0.8.4 вышла 11 октября 2011 года, и начиная с 2008 года изменения содержат только исправления ошибок.

На момент последней активности проект имел стабильную поддержку архитектур x86 и x86\_64, а также эксперементальную поддержку PowerPC, PowerPC64 и arm, но кросс-архитектурная трансляции не поддерживается. Кроме того, как и DMTCP проект требует предварительно загрузки вспомогательных библиотек вместе с целевым процессом.

\section{Цель работы}

\textit{1 страница}

Реализация POC технологии кросс-архитектурной миграции процессов с использование динамической трансляции. Оценка потерь проихзводительности при миграции с процессоров x86 на arm.

Основные принципы при проектировании:

\begin{itemize}

\item минимизация вмешательства в ядро
\item минимальная поддержка со стороны процесса
\item архитектура расширяемая на новые платформы

\end{itemize}

\section{Ресурсы процесса}

\textit{1 страница}

список ресурсов процесса. Память и состояние регистров минимальны набор ресурсов которые необходимо перенести при миграции процесса.

\subsection{Память процесса Linux}

\textit{1 страница}

Карта памяти процесса Linux (картинка). Регионы памяти процесса в Linux заняты кодом программы, загруженными динамическими библиотеками, стек, куча. Назначение участков памяти процесса.

\subsection{Регистры x86}

\textit{0.5 страницы}

Процессоры x86 - cisc процессоры. Минимальный набор регистров для переноса - РОНы + IP и SP.

\subsection{Файловые дескрипторы}

\textit{0.5 страницы}

Файловые дескрипторы в пространстве пользователя, файловые дескрипторы в пространстве ядра. Специальные файлы - файлы устройств и файовая система proc.

\subsection{Сокеты}

\textit{0.5 страницы}

Сокеты в пространсве пользователя, сокеты в пространстве ядра.

\subsection{Переменные окружения}

\textit{0.5 страницы}

Переменные окружения процесса Linux. Доступ к переменным окружения со стороны процесса Linux. Влияние переменных окружения на работу процесса.
